---
# Dotfiles configuration playbook for dotfiles installation
# This manages dotfile configurations using stow

- name: "Display dotfiles configuration plan"
  debug:
    msg:
      - "Configuring dotfiles for {{ ansible_distribution }}"
      - "Dotfiles path: {{ dotfiles.local_path }}"
      - "Target directory: {{ stow.target_dir }}"
      - "Stow packages: {{ stow.packages | join(', ') }}"
      - "Create backup: {{ dotfiles.create_backup }}"

- name: "Verify we're in the dotfiles directory"
  stat:
    path: "{{ dotfiles.local_path }}"
  register: dotfiles_directory_check

- name: "Fail if dotfiles directory doesn't exist"
  fail:
    msg: "Dotfiles directory {{ dotfiles.local_path }} does not exist"
  when: not dotfiles_directory_check.stat.exists

- name: "Check if stow is available"
  command: which stow
  register: stow_available_check
  failed_when: false
  changed_when: false

- name: "Install stow if not available"
  package:
    name: stow
    state: present
  when: stow_available_check.rc != 0

# Backup existing configurations
- name: "Create backup directory with timestamp"
  file:
    path: "{{ dotfiles.backup_dir }}-{{ ansible_date_time.epoch }}"
    state: directory
    owner: "{{ dotfiles.user }}"
    group: "{{ dotfiles.user }}"
    mode: '0755'
  register: backup_directory
  when: dotfiles.create_backup
  become_user: "{{ dotfiles.user }}"

- name: "Check for existing configuration files to backup"
  stat:
    path: "{{ stow.target_dir }}/{{ item }}"
  register: existing_configs
  loop:
    - .zshrc
    - .zsh_aliases
    - .tmux.conf
    - .config/nvim
    - .config/ghostty
    - .config/zed
    - .config/alacritty
    - .config/kitty
  become_user: "{{ dotfiles.user }}"

- name: "Backup existing configuration files"
  copy:
    src: "{{ item.stat.path }}"
    dest: "{{ backup_directory.path }}/"
    remote_src: true
    owner: "{{ dotfiles.user }}"
    group: "{{ dotfiles.user }}"
    mode: preserve
  when:
    - dotfiles.create_backup
    - item.stat.exists
  loop: "{{ existing_configs.results }}"
  loop_control:
    label: "{{ item.item }}"
  become_user: "{{ dotfiles.user }}"

# Install Oh My Zsh if enabled
- name: "Check if Oh My Zsh is already installed"
  stat:
    path: "{{ ansible_env.HOME }}/.oh-my-zsh"
  register: oh_my_zsh_check
  become_user: "{{ dotfiles.user }}"

- name: "Download and install Oh My Zsh"
  shell: 'sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended'
  become_user: "{{ dotfiles.user }}"
  when:
    - shell.install_oh_my_zsh
    - not oh_my_zsh_check.stat.exists

- name: "Create zsh plugins directory"
  file:
    path: "{{ ansible_env.HOME }}/.zsh"
    state: directory
    owner: "{{ dotfiles.user }}"
    group: "{{ dotfiles.user }}"
    mode: '0755'
  become_user: "{{ dotfiles.user }}"

- name: "Install zsh-autosuggestions plugin"
  git:
    repo: "https://github.com/zsh-users/zsh-autosuggestions"
    dest: "{{ ansible_env.HOME }}/.zsh/zsh-autosuggestions"
    version: master
  become_user: "{{ dotfiles.user }}"
  when: "'zsh-autosuggestions' in shell.oh_my_zsh_plugins"

- name: "Install zsh-syntax-highlighting plugin"
  git:
    repo: "https://github.com/zsh-users/zsh-syntax-highlighting.git"
    dest: "{{ ansible_env.HOME }}/.zsh/zsh-syntax-highlighting"
    version: master
  become_user: "{{ dotfiles.user }}"
  when: "'zsh-syntax-highlighting' in shell.oh_my_zsh_plugins"

# Setup tmux plugin manager
- name: "Check if TPM (Tmux Plugin Manager) is installed"
  stat:
    path: "{{ tmux.tpm_path }}"
  register: tpm_check
  become_user: "{{ dotfiles.user }}"

- name: "Create tmux plugins directory"
  file:
    path: "{{ tmux.tpm_path | dirname }}"
    state: directory
    owner: "{{ dotfiles.user }}"
    group: "{{ dotfiles.user }}"
    mode: '0755'
  become_user: "{{ dotfiles.user }}"
  when: tmux.install_tpm

- name: "Install TPM (Tmux Plugin Manager)"
  git:
    repo: "https://github.com/tmux-plugins/tpm"
    dest: "{{ tmux.tpm_path }}"
    version: master
  become_user: "{{ dotfiles.user }}"
  when:
    - tmux.install_tpm
    - not tpm_check.stat.exists

# Check which stow packages are available
- name: "Check which stow packages exist"
  stat:
    path: "{{ dotfiles.local_path }}/{{ item }}"
  register: stow_package_check
  loop: "{{ stow.packages }}"
  become_user: "{{ dotfiles.user }}"

- name: "Create list of available stow packages"
  set_fact:
    available_stow_packages: "{{ available_stow_packages | default([]) + [item.item] }}"
  when: item.stat.exists and item.stat.isdir
  loop: "{{ stow_package_check.results }}"
  loop_control:
    label: "{{ item.item }}"

- name: "Display available packages"
  debug:
    msg:
      - "Available stow packages: {{ available_stow_packages | default([]) | join(', ') }}"
      - "Missing packages: {{ stow.packages | difference(available_stow_packages | default([])) | join(', ') }}"

# Remove conflicting files before stowing (adoption strategy)
- name: "Check for conflicting files before stowing"
  shell: |
    cd "{{ dotfiles.local_path }}"
    stow --simulate --verbose {{ item }} 2>&1 || true
  register: stow_conflicts
  loop: "{{ available_stow_packages | default([]) }}"
  become_user: "{{ dotfiles.user }}"
  when: not stow.simulate

- name: "Display stow conflict information"
  debug:
    msg: "Stow conflicts for {{ item.item }}: {{ item.stderr_lines | default([]) }}"
  loop: "{{ stow_conflicts.results | default([]) }}"
  loop_control:
    label: "{{ item.item }}"
  when: item.stderr_lines is defined and item.stderr_lines | length > 0

# Stow dotfiles configurations
- name: "Stow dotfiles packages (dry run)"
  shell: |
    cd "{{ dotfiles.local_path }}"
    stow --simulate --verbose {{ item }} -t "{{ stow.target_dir }}"
  register: stow_dry_run
  loop: "{{ available_stow_packages | default([]) }}"
  become_user: "{{ dotfiles.user }}"
  when: stow.simulate
  failed_when: false

- name: "Display dry run results"
  debug:
    msg:
      - "Dry run for {{ item.item }}:"
      - "{{ item.stdout_lines | default([]) }}"
  loop: "{{ stow_dry_run.results | default([]) }}"
  loop_control:
    label: "{{ item.item }}"
  when: stow.simulate

- name: "Stow dotfiles packages"
  shell: |
    cd "{{ dotfiles.local_path }}"
    stow {{ '--verbose' if stow.verbose else '' }} "{{ item }}" -t "{{ stow.target_dir }}"
  register: stow_results
  loop: "{{ available_stow_packages | default([]) }}"
  become_user: "{{ dotfiles.user }}"
  when: not stow.simulate
  failed_when: false

- name: "Create list of successfully stowed packages"
  set_fact:
    stowed_packages: "{{ stowed_packages | default([]) + [item.item] }}"
  when: item.rc == 0
  loop: "{{ stow_results.results | default([]) }}"
  loop_control:
    label: "{{ item.item }}"

- name: "Create list of failed stow packages"
  set_fact:
    failed_stow_packages: "{{ failed_stow_packages | default([]) + [item.item] }}"
  when: item.rc != 0
  loop: "{{ stow_results.results | default([]) }}"
  loop_control:
    label: "{{ item.item }}"

- name: "Handle stow conflicts with adoption"
  shell: |
    cd "{{ dotfiles.local_path }}"
    stow --adopt "{{ item.item }}" -t "{{ stow.target_dir }}"
  register: stow_adopt_results
  loop: "{{ failed_stow_packages | default([]) }}"
  become_user: "{{ dotfiles.user }}"
  when:
    - not stow.simulate
    - failed_stow_packages is defined
    - failed_stow_packages | length > 0

- name: "Update stowed packages list after adoption"
  set_fact:
    stowed_packages: "{{ stowed_packages | default([]) + [item.item] }}"
  when: item.rc == 0
  loop: "{{ stow_adopt_results.results | default([]) }}"
  loop_control:
    label: "{{ item.item }}"

# Verify stowed configurations
- name: "Verify stowed symlinks"
  stat:
    path: "{{ stow.target_dir }}/{{ item.key }}"
  register: symlink_verification
  loop:
    - { key: ".zshrc", package: "zsh" }
    - { key: ".tmux.conf", package: "tmux" }
    - { key: ".config/nvim", package: "nvim" }
    - { key: ".config/ghostty", package: "ghostty" }
    - { key: ".config/zed", package: "zed" }
  become_user: "{{ dotfiles.user }}"
  when: item.package in (stowed_packages | default([]))

- name: "Create list of verified symlinks"
  set_fact:
    verified_symlinks: "{{ verified_symlinks | default([]) + [item.item.key] }}"
  when: item.stat.exists and item.stat.islnk
  loop: "{{ symlink_verification.results | default([]) }}"
  loop_control:
    label: "{{ item.item.key }}"

# Set correct permissions
- name: "Set correct permissions on dotfiles directory"
  file:
    path: "{{ dotfiles.local_path }}"
    mode: '0700'
    owner: "{{ dotfiles.user }}"
    group: "{{ dotfiles.user }}"
    recurse: false

- name: "Set executable permissions on shell scripts"
  shell: "find {{ dotfiles.local_path }} -name '*.sh' -type f -exec chmod 755 {} +"
  become_user: "{{ dotfiles.user }}"

# Post-configuration tasks
- name: "Source zsh configuration if it exists"
  shell: "source {{ stow.target_dir }}/.zshrc"
  become_user: "{{ dotfiles.user }}"
  when: "'.zshrc' in (verified_symlinks | default([]))"
  failed_when: false

- name: "Create useful aliases and functions"
  blockinfile:
    path: "{{ stow.target_dir }}/.zshrc"
    block: |
      # Dotfiles management aliases (added by Ansible)
      alias dotfiles="cd {{ dotfiles.local_path }}"
      alias stow-all="cd {{ dotfiles.local_path }} && make stow"
      alias unstow-all="cd {{ dotfiles.local_path }} && make unstow"
      alias config="cd {{ dotfiles.local_path }}"
    marker: "# {mark} ANSIBLE MANAGED BLOCK - Dotfiles aliases"
    create: false
  become_user: "{{ dotfiles.user }}"
  when: "'.zshrc' in (verified_symlinks | default([]))"

# Display results
- name: "Display dotfiles configuration results"
  debug:
    msg:
      - "=== Dotfiles Configuration Results ==="
      - "Successfully stowed: {{ stowed_packages | default([]) | join(', ') }}"
      - "Failed to stow: {{ failed_stow_packages | default([]) | join(', ') }}"
      - "Verified symlinks: {{ verified_symlinks | default([]) | length }}"
      - "Backup created: {{ 'Yes at ' + backup_directory.path if dotfiles.create_backup and backup_directory.path is defined else 'No' }}"
      - "Oh My Zsh installed: {{ 'Yes' if shell.install_oh_my_zsh and not oh_my_zsh_check.stat.exists else 'Already installed' if oh_my_zsh_check.stat.exists else 'No' }}"
      - "TPM installed: {{ 'Yes' if tmux.install_tpm and not tpm_check.stat.exists else 'Already installed' if tpm_check.stat.exists else 'No' }}"

- name: "Display important post-configuration notes"
  debug:
    msg:
      - ""
      - "Important post-configuration steps:"
      - "1. Restart your terminal or run: exec zsh"
      - "2. Open tmux and press prefix + I to install tmux plugins"
      - "3. Open neovim - plugins will install automatically"
      - "4. If you see conflicts, review git status in {{ dotfiles.local_path }}"
      - ""
      - "Useful commands after configuration:"
      - "- dotfiles: Navigate to dotfiles directory"
      - "- config: Alias for dotfiles directory"
      - "- stow-all: Re-apply all configurations"
      - "- unstow-all: Remove all configurations"
      - ""

- name: "Git status check notification"
  debug:
    msg:
      - "NOTE: If stow used --adopt, check git status for any changes:"
      - "cd {{ dotfiles.local_path }} && git status"
      - "Review and commit any changes that were adopted from existing configs."
  when:
    - stow_adopt_results is defined
    - stow_adopt_results.results | selectattr('rc', 'equalto', 0) | list | length > 0

- name: "Set dotfiles completion fact"
  set_fact:
    dotfiles_completed: true
    configured_dotfiles: "{{ stowed_packages | default([]) }}"
    dotfiles_configuration_summary:
      stowed: "{{ stowed_packages | default([]) }}"
      failed: "{{ failed_stow_packages | default([]) }}"
      verified_symlinks: "{{ verified_symlinks | default([]) | length }}"
      backup_created: "{{ dotfiles.create_backup and backup_directory.path is defined }}"
      backup_location: "{{ backup_directory.path if dotfiles.create_backup and backup_directory.path is defined else 'none' }}"
